---
title: "YAMLResume v0.7: 開発モード"
description: |
  YAMLResume v0.7 は新しい `dev` モードを導入し、リアルタイム、ウォッチモードの履歴書作成体験を提供し、開発者体験を大幅に向上させます。
author: Xiao Hanyu
profile: https://x.com/xiaohanyu1988
date: 2025-08-30
---

私は [YAMLResume v0.7](https://github.com/yamlresume/yamlresume/releases/tag/v0.7.0) の紹介に非常に興奮しています。これは開発者体験（DX）の向上に焦点を当てたリリースです。このアップデートの中心は新しい [`dev` モード](/ja/docs/cli#dev) で、履歴書作成プロセスにシームレスでリアルタイムの開発ワークフローをもたらす機能です。

![開発モードワークフロー](/static/images/blog/dev-mode/dev-mode-vs-code.webp)

面倒な編集-保存-ビルドのサイクルの日々は終わりました。`dev` モードにより、YAMLResume は履歴書ファイルの変更を監視し、ほぼリアルタイムで PDF を自動的に再ビルドします。この一見シンプルな追加により、履歴書作成の体験が流動的でインタラクティブ、そしてはるかに楽しいプロセスに変わります。

## 古いワークフローの摩擦

v0.7 以前は、YAMLResume で履歴書を作成することは強力でしたが、反復的で手動のプロセスを伴いました。以下の手順が必要でした：

1. お好みのテキストエディタで `my-resume.yml` ファイルを開く
2. 変更を加える—仕事の説明を更新したり、新しいスキルを追加したり
3. ファイルを保存
4. ターミナルに切り替え
5. `yamlresume build my-resume.yml` コマンドを実行
6. コマンドの完了を待つ
7. PDF ビューアに切り替えて更新して結果を確認
8. 小さなタイポやフォーマットの問題に気づく
9. サイクル全体を繰り返す

以下に示すこのループは、履歴書作成プロセスに大きな摩擦をもたらしました。小さな変更でも、コンテキストスイッチと手動コマンド実行が必要でした。この継続的な中断は創造的な流れを破り、履歴書を磨くプロセスを遅くします。

<Mermaid
  chart={`
graph TD
  A[my-resume.yml を編集] --> B{ファイルを保存};
  B --> C[ターミナルに切り替え];
  C --> D['yamlresume build' を実行];
  D --> E{ビルドを待つ};
  E --> F[PDF ビューアに切り替え];
  F --> G{PDF を更新};
  G --> H{変更を確認};
  H -- 修正が必要 --> A;
  H -- 良さそう --> I[完了];
  subgraph 手動ビルドサイクル
    A
    B
    C
    D
    E
    F
    G
    H
  end
`}
/>

現代のソフトウェア開発の世界では、即座のフィードバックを提供するツールに慣れています。Web 開発者は [ホットリロード](https://webpack.js.org/concepts/hot-module-replacement/) を持ち、コードを変更するとブラウザが自動的に更新されます。この密接なフィードバックループは生産性にとって重要で、優れた開発者体験の核心原則です。履歴書をコードとして作成することも同じであるべきだと信じています。

## 解決策：シームレスな開発モード

`yamlresume dev` コマンドは手動ビルドサイクルを完全に排除します。一度起動すれば、バックグラウンドで静かに動作し、変更を監視して履歴書を自動的に再ビルドします。

開発モードを開始するには、単純に実行してください：

```bash
yamlresume dev my-resume.yml
```

これで、`my-resume.yml` ファイルと PDF を並べて開くことができます。YAML ファイルに変更を保存するたびに、YAMLResume が自動的に検出して再ビルドをトリガーします。PDF ビューアは数秒後に更新され、履歴書の最新バージョンを表示します。

新しいワークフローは大幅にシンプルで効率的です：

<Mermaid chart={`
graph TD
  A['yamlresume dev' を開始] --> B[my-resume.yml を編集];
  B --> C{ファイルを保存};
  C --> D{PDF が自動的に再ビルド};
  D --> E{PDF で変更を確認};
  E -- 修正が必要 --> B;
  E -- 良さそう --> F[開発モードを停止];

  subgraph リアルタイムワークフロー
    B
    C
    D
    E
  end
`}/>

この即座のフィードバックループにより、継続的なコンテキストスイッチなしに、迅速に反復し、異なる表現を試し、履歴書のレイアウトを完璧にすることができます。このプロセスを雑用ではなく、創造的な取り組みのように感じさせます。

以下は `dev` モードの実際のデモです：

<video
  autoPlay
  controls
  loop
  muted
  src="/static/videos/blog/dev-mode/dev-mode-vs-code-demo.mp4"
/>

詳細については [YouTube デモ](https://youtu.be/xytlzedEQ_w) をご覧ください。

## 仕組み：内部の仕組み

`dev` モードは使用が簡単ですが、堅牢で効率的であることを保証するために、背後で興味深い技術が働いています。

### ファイルウォッチャー：`chokidar`

`dev` モードの中心はファイルウォッチャーです。素朴なアプローチは Node.js の組み込み [`fs.watch` API](https://nodejs.org/docs/latest/api/fs.html#fswatchfilename-options-listener) を使用することです。しかし、`fs.watch` には既知の制限があり、異なるオペレーティングシステム間で一貫性がありません。さらに重要なのは、特定のテキストエディタの動作で苦労することです。

例えば、Vim のようなエディタは「アトミック保存」戦略を使用します。ファイルを保存する際、Vim は元のファイルに直接書き込みません。代わりに、変更を一時ファイル（有名な `.swp` ファイル）に書き込み、その一時ファイルを元のファイルを置き換えるためにリネームします。このプロセスは基本的なファイルウォッチャーを混乱させ、変更を完全に見逃したり、複数のイベントをトリガーしたりする可能性があります。

信頼できる体験を提供するため、**[chokidar](https://github.com/paulmillr/chokidar)** を採用しました。これは人気で実戦でテストされたファイルウォッチングライブラリです。Chokidar はクロスプラットフォームの不整合を抽象化し、これらのトリッキーなエディタの動作を優雅に処理するように特別に設計されています。ファイルの書き込みが完了するまで待つように設定し、部分的に保存されたファイルをビルドしようとしないことを保証しています。

### ビルドストームの防止：`coalescifn`

ファイルを短時間で複数回保存するとどうなるでしょうか？シンプルな実装では、すべての保存イベントに対して新しいビルドを開始しようとするかもしれません。これにより「ビルドストーム」が発生し、複数のビルドプロセスが同時に実行され、不要なシステムリソースを消費し、競合状態を引き起こす可能性があります。

この問題を解決するため、[coalescifn](https://github.com/yamlresume/coalescifn) という巧妙な小さなユーティリティを書き、オープンソース化しました。このユーティリティは複数の呼び出しを**一つにまとめる**のに役立ちます。以下は `dev` モードのコンテキストでの動作方法です：

1. 最初のファイル変更が検出されると、すぐにビルドを開始します
2. そのビルドが実行中にさらに変更が検出された場合、新しいビルドを開始しません。単にファイルが再び変更されたことを記録します
3. 初期ビルドが完了すると、その間にさらに変更が発生したかどうかを確認します
4. 後続の変更があった場合、最終 PDF がファイルの最新バージョンを反映することを保証するために、正確に**もう一つ**のビルドを実行します。新しい変更がなかった場合、何もしずに次の保存イベントを待ちます

この戦略により、一度に実行されるビルドは一つだけで、最終ビルドが常に履歴書ファイルの最新バージョンを使用することを保証します。これは `dev` モードを応答性が高く、システムリソースを軽く保つ効率的なアプローチです。

以下は合体ロジックを説明する図です：

<Mermaid chart={`
sequenceDiagram
  participant User
  participant Watcher
  participant Coalesce
  participant Builder

  User->>Watcher: ファイルを保存 (t=0s)
  Watcher->>Coalesce: ビルドをトリガー
  Coalesce->>Builder: ビルド #1 を開始
  User->>Watcher: ファイルを保存 (t=1s)
  Watcher->>Coalesce: ビルドをトリガー (無視、ビルド進行中)
  User->>Watcher: ファイルを保存 (t=2s)
  Watcher->>Coalesce: ビルドをトリガー (無視、ビルド進行中)
  Builder-->>Coalesce: ビルド #1 完了 (t=3s)
  Coalesce->>Builder: ビルド #2 を開始 (最新ファイル内容で)
  Builder-->>Coalesce: ビルド #2 完了 (t=6s)
`}/>

## 高度な制御

`dev` コマンドには、`build` コマンドで利用可能なフラグをミラーして、ビルドプロセスをより細かく制御できるオプションも付属しています。

### PDF 生成のスキップ

時々、YAMLResume が生成する中間 LaTeX (`.tex`) ファイルを検査したいだけの場合があります。これはデバッグや、LaTeX コードを手動で調整したい人にとって有用です。PDF の生成はビルドプロセスで最も時間のかかる部分です。必要ない場合は、`dev` モードにスキップするよう指示できます：

```bash
yamlresume dev my-resume.yml --no-pdf
```

このフラグを使用すると、`dev` モードは変更を監視し、`.tex` ファイルを即座に再生成しますが、`xelatex` コマンドは実行しません。これにより再ビルドプロセスがほぼ瞬時に完了します。

### 検証の無効化

[v0.5](/ja/blog/yamlresume-compiler) から、YAMLResume にはビルド中に履歴書の潜在的なエラーをキャッチする強力なスキーマ検証ステップが含まれています。これは正確性を保証するのに非常に有用ですが、一時的に無効にしたい場合があります。例えば、履歴書構造の大きなリファクタリングの途中で、検証エラーに中断されたくない場合があります。

`--no-validate` フラグで検証を無効にできます：

```bash
yamlresume dev my-resume.yml --no-validate
```

これにより、履歴書が適切に形成されていることを確認するために後で検証を再有効化する必要があることを理解した上で、より自由に作業できます。

## 「履歴書即コード」の新しい DX

`dev` モードの導入は単なる新機能以上のものです。これは「履歴書即コード」の真の約束を果たすための一歩です。静的でコマンドライン駆動のプロセスから、現代のソフトウェア開発により似た動的でインタラクティブなプロセスに体験を向上させます。

過去に `npm run build` と `npm run dev` に慣れていましたか？YAMLResume には同じワークフローが組み込まれています。

フィードバックループを閉じることで、美しくプロフェッショナルな履歴書をより簡単に、より速く作成できるようになります。これにより、より多くの実験が奨励され、本当に重要なことに集中できるようになると信じています：履歴書の内容と、それがあなたのプロフェッショナルなストーリーをどのように語るかです。

YAMLResume v0.7 に更新して、新しい `dev` モードを体験してください：

- **インストールまたは更新** 最新バージョンへ：`npm install -g yamlresume@latest`
- **試してみる** 既存の履歴書で：`yamlresume dev my-resume.yml`
- **コミュニティに参加** [GitHub](https://github.com/yamlresume/yamlresume/discussions) でフィードバックを共有し、質問したり、YAMLResume の未来に貢献したりしてください

履歴書作成の最高の開発者体験を構築することにコミットしており、この新リリースについてどう思うかを聞くのが待ちきれません！
